<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake — Simple Game</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#10b981;--muted:#94a3b8}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071229 0%,#071826 100%);color:#e6eef8}
    .wrap{width:min(920px,96vw);display:grid;grid-template-columns:1fr 320px;gap:20px;align-items:start}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;padding:16px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}
    canvas{width:100%;height:calc(100% - 0px);background:linear-gradient(180deg,#031025,#04132a);border-radius:8px;display:block}
    .controls{display:flex;gap:8px;margin-top:12px}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);padding:8px 12px;border-radius:8px;cursor:pointer}
    button.ghost{border-color:rgba(255,255,255,0.04);color:var(--muted)}
    h1{font-size:18px;margin:0 0 8px}
    .meta{display:flex;flex-direction:column;gap:8px}
    .stat{display:flex;justify-content:space-between;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01)}
    .hint{font-size:13px;color:var(--muted)}
    .footer{font-size:13px;color:var(--muted);margin-top:12px}
    .big-score{font-size:28px;color:var(--accent);font-weight:700}
    @media (max-width:880px){.wrap{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" style="min-height:440px;">
      <h1>Snake — Play</h1>
      <canvas id="game" width="640" height="480"></canvas>
      <div class="controls">
        <button id="btnPause">Pause</button>
        <button id="btnRestart" class="ghost">Restart</button>
        <button id="btnEasy" class="ghost">Easy</button>
        <button id="btnNormal" class="ghost">Normal</button>
        <button id="btnHard" class="ghost">Hard</button>
      </div>
      <div class="hint">Controls: Arrow keys or WASD. Space to pause. On touch — swipe.</div>
    </div>

    <div class="card">
      <div class="meta">
        <div class="stat"><div>Score</div><div id="score" class="big-score">0</div></div>
        <div class="stat"><div>Highscore</div><div id="high">0</div></div>
        <div class="stat"><div>Speed</div><div id="speedText">Normal</div></div>
        <div class="stat"><div>Grid</div><div id="gridSize">20 × 15</div></div>
      </div>
      <div class="footer">Made with HTML/CSS/JS • Mobile friendly • Refresh page to reset highscore</div>
    </div>
  </div>

  <script>
    // Basic snake game — single file, no libraries
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // logical grid size
    let cols = 20; // horizontal cells
    let rows = 15; // vertical cells
    let tileSize = Math.floor(Math.min(canvas.width/cols, canvas.height/rows));

    // state
    let snake = [{x:Math.floor(cols/2), y:Math.floor(rows/2)}];
    let dir = {x:1,y:0};
    let nextDir = {x:1,y:0};
    let food = null;
    let running = true;
    let score = 0;
    let high = 0;
    let speed = 8; // frames per second
    let gameLoopId = null;
    let paused = false;

    // DOM
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high');
    const gridEl = document.getElementById('gridSize');
    const speedText = document.getElementById('speedText');

    // init
    function reset(){
      snake = [{x:Math.floor(cols/2), y:Math.floor(rows/2)}];
      dir = {x:1,y:0};
      nextDir = {x:1,y:0};
      score = 0;
      running = true;
      paused = false;
      placeFood();
      updateHUD();
    }

    function placeFood(){
      while(true){
        const f = {x:Math.floor(Math.random()*cols), y:Math.floor(Math.random()*rows)};
        if(!snake.some(s=>s.x===f.x && s.y===f.y)){ food=f; break }
      }
    }

    function updateHUD(){
      scoreEl.textContent = score;
      highEl.textContent = high;
      gridEl.textContent = cols + ' × ' + rows;
    }

    function step(){
      if(!running || paused) return;
      dir = nextDir;
      const head = {x:snake[0].x + dir.x, y:snake[0].y + dir.y};

      // wall wrap
      if(head.x < 0) head.x = cols - 1;
      if(head.x >= cols) head.x = 0;
      if(head.y < 0) head.y = rows - 1;
      if(head.y >= rows) head.y = 0;

      // self collision
      if(snake.some(s => s.x === head.x && s.y === head.y)){
        gameOver();
        return;
      }

      snake.unshift(head);

      // ate food?
      if(food && head.x === food.x && head.y === food.y){
        score += 1;
        if(score > high) high = score;
        placeFood();
        updateHUD();
      } else {
        snake.pop();
      }

      draw();
    }

    function gameOver(){
      running = false;
      paused = false;
      updateHUD();
      // flash effect
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = '24px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('GET TROLLED — Press Restart', canvas.width/2, canvas.height/2);
    }

    function draw(){
      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // draw grid background subtle
      ctx.fillStyle = '#051423';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // draw food
      if(food){
        const fx = food.x * tileSize + 2;
        const fy = food.y * tileSize + 2;
        const r = Math.max(4, tileSize/3 - 2);
        ctx.fillStyle = '#ff5f6d';
        roundRect(ctx, fx, fy, tileSize-4, tileSize-4, 6);
        ctx.fill();
      }

      // draw snake
      for(let i=0;i<snake.length;i++){
        const s = snake[i];
        const x = s.x * tileSize + 1;
        const y = s.y * tileSize + 1;
        ctx.beginPath();
        const grad = ctx.createLinearGradient(x,y,x+tileSize,y+tileSize);
        grad.addColorStop(0,'#10b981');
        grad.addColorStop(1,'#065f46');
        ctx.fillStyle = grad;
        roundRect(ctx, x, y, tileSize-2, tileSize-2, 6);
        ctx.fill();
        if(i===0){
          // eyes
          ctx.fillStyle = '#071923';
          const ex = x + (dir.x===-1 ? 6 : dir.x===1 ? tileSize-12 : 6);
          const ey1 = y + 6;
          const ey2 = y + tileSize - 12;
          ctx.fillRect(ex, ey1, 4, 4);
          ctx.fillRect(ex, ey2, 4, 4);
        }
      }
    }

    function roundRect(ctx, x, y, w, h, r){
      const min = Math.min(w,h)/2;
      if(r>min) r=min;
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    // input
    window.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();
      if(k === 'arrowup' || k === 'w') tryTurn(0,-1);
      if(k === 'arrowdown' || k === 's') tryTurn(0,1);
      if(k === 'arrowleft' || k === 'a') tryTurn(-1,0);
      if(k === 'arrowright' || k === 'd') tryTurn(1,0);
      if(k === ' ') togglePause();
    });

    function tryTurn(x,y){
      // prevent reversing
      if(dir.x === -x && dir.y === -y) return;
      nextDir = {x,y};
    }

    // touch swipe
    (function touchControls(){
      let startX=0,startY=0;const threshold=20;
      canvas.addEventListener('touchstart', e=>{const t=e.touches[0];startX=t.clientX;startY=t.clientY});
      canvas.addEventListener('touchmove', e=>e.preventDefault(), {passive:false});
      canvas.addEventListener('touchend', e=>{
        const t = e.changedTouches[0];
        const dx = t.clientX - startX; const dy = t.clientY - startY;
        if(Math.abs(dx) > Math.abs(dy)){
          if(dx > threshold) tryTurn(1,0);
          else if(dx < -threshold) tryTurn(-1,0);
        } else {
          if(dy > threshold) tryTurn(0,1);
          else if(dy < -threshold) tryTurn(0,-1);
        }
      });
    })();

    // UI buttons
    document.getElementById('btnPause').addEventListener('click', togglePause);
    document.getElementById('btnRestart').addEventListener('click', ()=>{ reset(); });
    document.getElementById('btnEasy').addEventListener('click', ()=>{ setDifficulty('easy'); });
    document.getElementById('btnNormal').addEventListener('click', ()=>{ setDifficulty('normal'); });
    document.getElementById('btnHard').addEventListener('click', ()=>{ setDifficulty('hard'); });

    function togglePause(){ paused = !paused; document.getElementById('btnPause').textContent = paused ? 'Resume' : 'Pause'; }

    function setDifficulty(level){
      if(level==='easy'){ speed=6; cols=18; rows=12; speedText.textContent='Easy'; }
      if(level==='normal'){ speed=10; cols=20; rows=15; speedText.textContent='Normal'; }
      if(level==='hard'){ speed=14; cols=24; rows=18; speedText.textContent='Hard'; }
      tileSize = Math.floor(Math.min(canvas.width/cols, canvas.height/rows));
      reset();
      updateHUD();
    }

    // responsive canvas resize
    function fitCanvas(){
      // keep aspect ratio 4:3
      const maxW = Math.min(920, window.innerWidth*0.96);
      const maxH = Math.min(640, window.innerHeight*0.6);
      const ratio = 4/3;
      let w = Math.min(maxW, maxH * ratio);
      let h = Math.min(maxH, w / ratio);
      canvas.width = Math.floor(w);
      canvas.height = Math.floor(h);
      tileSize = Math.floor(Math.min(canvas.width/cols, canvas.height/rows));
      draw();
    }
    window.addEventListener('resize', fitCanvas);

    // main loop using setInterval (simple & stable)
    function startLoop(){
      if(gameLoopId) clearInterval(gameLoopId);
      gameLoopId = setInterval(step, 1000 / speed);
    }

    // allow speed changes to take effect
    setInterval(()=>{ if(gameLoopId){ clearInterval(gameLoopId); gameLoopId = setInterval(step, 1000 / speed); } }, 500);

    // start
    fitCanvas();
    reset();
    startLoop();
  </script>
</body>
</html>
